require "openssl/hmac"
require "json"
require "yaml"

module MessageVerifier
  class Verifier
    def initialize(@secret : String, @digest : OpenSSL::Algorithm = OpenSSL::Algorithm::SHA1)
    end

    # Checks if a signed message could have been generated by signing an object
    # with the +MessageVerifier+'s secret.
    #
    #   verifier = MessageVerifier::Verifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #   verifier.valid_message?(signed_message) # => true
    #
    #   tampered_message = signed_message.chop # editing the message invalidates the signature
    #   verifier.valid_message?(tampered_message) # => false
    def valid_message?(signed_message : String)
      return false if signed_message.blank? || !signed_message.valid_encoding?

      data, digest = signed_message.split("--")
      !data.blank? && !digest.blank? && Util.secure_compare(digest, generate_digest(data))
    end

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = MessageVerifier::Verifier.new 's3Krit'
    #
    #   signed_message = verifier.generate 'a private message'
    #   verifier.verified(signed_message) # => 'a private message'
    #
    # Returns +nil+ if the message was not signed with the same secret.
    #
    #   other_verifier = MessageVerifier::Verifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verified(signed_message) # => nil
    #
    #
    # Returns +nil+ if the message is not Base64-encoded.
    #
    #   invalid_message = "f--46a0120593880c733a53b6dad75b42ddc1c8996d"
    #   verifier.verified(invalid_message) # => nil
    def verified(signed_message, purpose : String | Symbol | ::Nil = nil, parser : ::Nil | Symbol = :JSON)
      if valid_message?(signed_message)
        data = signed_message.split("--").first
        metadata = MessageVerifier::Metadata.verify(decode(data), purpose)

        load(metadata.to_s, parser) if metadata
      end
    rescue InvalidSignature
      nil
    end

    # Same as #verify, however it raises an exception instead of returning nil
    def verified!(signed_message, purpose : String | Symbol | ::Nil = nil, parser : ::Nil | Symbol = :JSON)
      if valid_message?(signed_message)
        data = signed_message.split("--").first
        metadata = MessageVerifier::Metadata.verify(decode(data), purpose)

        load(metadata.to_s, parser) if metadata
      end
    end

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = MessageVerifier::Verifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #
    #   verifier.verify(signed_message) # => 'a private message'
    #
    # Raises +InvalidSignature+ if the message was not signed with the same
    # secret or has expired
    #
    #   other_verifier = MessageVerifier::Verifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature
    def verify(signed_message : String, purpose : String | Symbol | ::Nil = nil, parser : ::Nil | Symbol = :JSON)
      verified!(signed_message, purpose: purpose, parser: parser) || raise(InvalidSignature.new)
    end

    # Generates a signed message for the provided value.
    #
    # The message is signed with the +MessageVerifier+'s secret. Without knowing
    # the secret, the original value cannot be extracted from the message.
    #
    #   verifier = MessageVerifier::Verifier.new 's3Krit'
    #   verifier.generate 'a private message' # => "BAhJIhRwcml2YXRlLW1lc3NhZ2UGOgZFVA==--e2d724331ebdee96a10fb99b089508d1c72bd772"
    def generate(message : String, expires_at : Time | ::Nil = nil, expires_in : Int64 | ::Nil = nil, purpose : String | Symbol | ::Nil = nil)
      data = encode(MessageVerifier::Metadata.wrap(message, expires_at: expires_at, expires_in: expires_in, purpose: purpose))
      "#{data}--#{generate_digest(data)}"
    end

    private def encode(string)
      ::Base64.strict_encode(string)
    end

    private def decode(string)
      ::Base64.decode_string(string)
    end

    private def generate_digest(data)
      OpenSSL::HMAC.hexdigest(@digest, @secret, data)
    end

    private def load(message, parser)
      case parser
      when :YAML
        YAML.parse(message)
      when :JSON
        JSON.parse(message)
      else
        message
      end
    end
  end
end
